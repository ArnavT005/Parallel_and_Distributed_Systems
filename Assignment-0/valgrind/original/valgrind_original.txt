==23443== Cachegrind, a cache and branch-prediction profiler
==23443== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==23443== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==23443== Command: ./classify rfile dfile 1009072 4 3
==23443== 
--23443-- warning: L3 cache found, using its data for the LL simulation.
28802.9 ms
29690.5 ms
29863.1 ms
3 iterations of 1009072 items in 1001 ranges with 4 threads: Fastest took 28802.9 ms, Average was 29452.2 ms
==23443== 
==23443== I   refs:      34,207,795,679
==23443== I1  misses:             3,569
==23443== LLi misses:             3,410
==23443== I1  miss rate:           0.00%
==23443== LLi miss rate:           0.00%
==23443== 
==23443== D   refs:       6,448,230,466  (6,345,256,694 rd   + 102,973,772 wr)
==23443== D1  misses:       381,828,821  (  380,356,508 rd   +   1,472,313 wr)
==23443== LLd misses:         3,971,689  (    2,992,791 rd   +     978,898 wr)
==23443== D1  miss rate:            5.9% (          6.0%     +         1.4%  )
==23443== LLd miss rate:            0.1% (          0.0%     +         1.0%  )
==23443== 
==23443== LL refs:          381,832,390  (  380,360,077 rd   +   1,472,313 wr)
==23443== LL misses:          3,975,099  (    2,996,201 rd   +     978,898 wr)
==23443== LL miss rate:             0.0% (          0.0%     +         1.0%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./classify rfile dfile 1009072 4 3
Data file:        cachegrind.out.23443
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr            D1mr        DLmr      Dw          D1mw      DLmw    
--------------------------------------------------------------------------------
34,207,795,679 3,569 3,410 6,345,256,694 380,356,508 2,992,791 102,973,772 1,472,313 978,898  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr        DLmr      Dw         D1mw    DLmw     file:function
--------------------------------------------------------------------------------
18,202,683,189    7    7 3,042,355,239 378,792,417 2,804,623  3,027,300 381,051 380,613  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
15,116,191,724    6    5 3,028,689,333       1,535     1,267          0       0       0  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:Ranges::range(int, bool) const
   519,253,851   37   37   172,281,847         339       210 53,900,944       0       0  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   128,288,151  690  670    37,406,809         823       512  9,102,271     265     207  ???:???
    63,571,884    6    6    15,136,236   1,537,645   176,099  9,081,732      11       8  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
    62,687,028   10   10    25,276,949          45        41  7,077,639       0       0  ???:std::istream::sentry::sentry(std::istream&, bool)
    55,609,012    5    5    17,188,240           2         1 10,110,730 126,135   1,919  ???:std::istream::operator>>(int&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr        DLmr      Dw        D1mw    DLmw    

            .    .    .             .           .         .         .       .       .  #include "classify.h"
            .    .    .             .           .         .         .       .       .  #include <omp.h>
            .    .    .             .           .         .         .       .       .  
        9,009    2    2             0           0         0     3,003       0       0  Counter::Counter(unsigned int num=MAXTHREADS) {
        3,003    0    0             0           0         0     3,003       0       0     _numcount = num;
       12,012    0    0             0           0         0     6,006       3       1     _counts = new unsigned int[num];
            .    .    .             .           .         .         .       .       .     assert(_counts != NULL);
            .    .    .             .           .         .         .       .       .     zero();
        6,006    0    0         6,006           0         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Counter::zero() { // Initialize
      591,591    0    0         3,003           0         0         0       0       0     for(int i=0; i<_numcount; i++)
      192,192    0    0             0           0         0   192,192   9,668   9,662        _counts[i] = 0;
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Counter::increase(unsigned int id) { // If each sub-counter belongs to a thread mutual exclusion is not needed
   15,136,080    0    0     3,027,216      12,003       465         0       0       0     assert(id < _numcount);
   15,136,116    2    2     6,054,432      12,003     3,429 3,027,216       0       0     _counts[id]++;
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Counter::xincrease(unsigned int id) { // Safe increment
            .    .    .             .           .         .         .       .       .     assert(id < _numcount);
            .    .    .             .           .         .         .       .       .     const std::lock_guard<std::mutex> lock(cmutex);
            .    .    .             .           .         .         .       .       .     _counts[id]++;
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  unsigned int Counter::get(unsigned int id) const { // return subcounter value for specific thread
       33,033    1    1             0           0         0         0       0       0     assert(id < _numcount);
       48,048    0    0        24,024       3,002        37         0       0       0     return _counts[id];
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Counter::inspect() {
            .    .    .             .           .         .         .       .       .     std::cout << "Subcounts -- ";
            .    .    .             .           .         .         .       .       .     for(int i=0; i<_numcount; i++)
            .    .    .             .           .         .         .       .       .        std::cout << i << ":" << _counts[i] << " ";
            .    .    .             .           .         .         .       .       .     std::cout << "\n";
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
        1,000    1    1             0           0         0         0       0       0  Range::Range(int a=1, int b=0) { // Constructor. Defaults to *bad* range
      502,501    0    0             0           0         0   502,501  61,877  61,877     lo = a;
    1,004,000    1    1             0           0         0   502,500       0       0     hi = b;
        1,000    0    0         1,000           0         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  bool Range::within(int val) const { // Return if val is within this range
6,035,199,372    0    0 3,017,599,686       1,532     1,267         0       0       0        return(lo <= val && val <= hi);
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  bool Range::strictlyin(int val) const { // Return if val is strictly inside this range
    5,002,998    0    0     2,001,999           0         0         0       0       0        return(lo < val && val < hi);
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
            3    1    1             0           0         0         1       0       0  Ranges::Ranges() { // Initialize with a single unreal interval
            1    0    0             0           0         0         1       0       0     _num = 1;
            3    1    1             0           0         0         2       0       0     _ranges = new Range(1, 0); // Started with this. Its not a real interval as nothing lies inside it.
            2    0    0             2           0         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
        8,000    1    1             0           0         0     5,000       0       0  Ranges& Ranges::operator+=(const Range range){ // Add one more interval to this list
        3,000    0    0             0           0         0     1,000       0       0     if(newrange(range)) { // If it already exists, do not add
        1,000    0    0         1,000           0         0         0       0       0        Range *oranges = _ranges;
    1,018,000    1    1         1,000           0         0     2,000       0       0        _ranges = new Range[_num+1];
            .    .    .             .           .         .         .       .       .        assert(NULL != _ranges);
    1,507,500    0    0         1,000           0         0         0       0       0        for(int r=0; r<_num; r++) { 
    1,001,000    0    0     1,001,000           0         0         0       0       0           set(r, oranges[r].lo, oranges[r].hi); // copy old intervals
            .    .    .             .           .         .         .       .       .        }
        2,000    0    0             0           0         0     1,000       0       0        set(_num++, range.lo, range.hi); // Add the new interval at the end
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .     return *this;
        7,000    0    0         6,000           0         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
    3,029,216    3    2             0           0         0         0       0       0  int Ranges::range(int val, bool strict = false) const { // Tell the range in which val lies (strict => boundary match not ok)
    9,087,648    0    0     3,029,216           0         0         0       0       0     if(strict) {
    5,005,000    1    1             0           0         0         0       0       0        for(int r=0; r<_num; r++) // Look through all intervals
        8,000    0    0         2,000           0         0         0       0       0           if(_ranges[r].strictlyin(val))
            .    .    .             .           .         .         .       .       .              return r;
            .    .    .             .           .         .         .       .       .     } else {
7,534,917,567    1    1             0           0         0         0       0       0        for(int r=0; r<_num; r++) // Look through all intervals
1,517,881,491    0    0     3,027,216           0         0         0       0       0           if(_ranges[r].within(val))
            .    .    .             .           .         .         .       .       .              return r;
            .    .    .             .           .         .         .       .       .     }
        2,000    1    1             0           0         0         0       0       0     return BADRANGE; // Did not find any range
    6,058,432    0    0     3,029,216           3         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Ranges::inspect() {
            .    .    .             .           .         .         .       .       .     for(int r=0; r<_num; r++) { 
            .    .    .             .           .         .         .       .       .        std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
        9,048    3    3            32          14         1         0       0       0  int Ranges::num() const { return _num; }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  void Ranges::set(int i, int lo, int hi) { // set the extreme values of a specific interval
            .    .    .             .           .         .         .       .       .     if(i < _num) {
      501,500    1    1             0           0         0   501,500       0       0        _ranges[i].lo = lo;
    1,001,000    0    0             0           0         0   500,500       0       0        _ranges[i].hi = hi;
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  }
            .    .    .             .           .         .         .       .       .  
        2,000    1    1             0           0         0         0       0       0  bool Ranges::newrange(const Range r) { // Is the range r already in my list, or is it a new one?
       12,000    0    0             0           0         0     2,000       0       0     return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE); // Overlaps are not allowed.
        1,000    0    0         1,000           0         0         0       0       0  }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .  Data classify(Data &D, const Ranges &R, unsigned int numt)
           36    5    5             3           0         0        21       0       0  {  
            .    .    .             .           .         .         .       .       .     // Classify each item in D into intervals (given by R). Finally, produce in D2 data sorted by interval
            6    0    0             0           0         0         0       0       0     assert(numt < MAXTHREADS);
       18,270    6    6            48          47        45     3,006       6       1     Counter counts[R.num()]; // I need on counter per interval. Each counter can keep pre-thread subcount.
          261    4    4           111          22         2        87       3       0     #pragma omp parallel num_threads(numt)
            .    .    .             .           .         .         .       .       .     {
           12    0    0             0           0         0        12       8       8        int tid = omp_get_thread_num(); // I am thread number tid
   12,108,900    0    0     3,027,240           3         0         0       0       0        for(int i=tid; i<D.ndata; i+=numt) { // Threads together share-loop through all of Data
   21,190,548    2    2     3,027,240   1,513,614   172,203 6,054,432       3       0           int v = D.data[i].value = R.range(D.data[i].key);// For each data, find the interval of data's key,
            .    .    .             .           .         .         .       .       .  							  // and store the interval id in value. D is changed.
            .    .    .             .           .         .         .       .       .           counts[v].increase(tid); // Found one key in interval v
            .    .    .             .           .         .         .       .       .        }
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .     // Accumulate all sub-counts (in each interval;'s counter) into rangecount
           21    0    0             3           0         0         3       0       0     unsigned int *rangecount = new unsigned int[R.num()];
        6,039    3    3             3           3         0         0       0       0     for(int r=0; r<R.num(); r++) { // For all intervals
        3,003    0    0             0           0         0     3,003     188     185        rangecount[r] = 0;
       33,033    0    0         3,003       3,000        12         0       0       0        for(int t=0; t<numt; t++) // For all threads
       12,012    0    0        12,012           0         0         0       0       0           rangecount[r] += counts[r].get(t);
            .    .    .             .           .         .         .       .       .        // std::cout << rangecount[r] << " elements in Range " << r << "\n"; // Debugging statement
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .     // Compute prefx sum on rangecount.
        6,018    0    0             0           0         0         0       0       0     for(int i=1; i<R.num(); i++) {
        6,000    0    0         6,000         146         0         0       0       0        rangecount[i] += rangecount[i-1];
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  
            .    .    .             .           .         .         .       .       .     // Now rangecount[i] has the number of elements in intervals before the ith interval.
            .    .    .             .           .         .         .       .       .  
            6    0    0             3           3         0         3       3       0     Data D2 = Data(D.ndata); // Make a copy
            .    .    .             .           .         .         .       .       .     
          261    2    2           108          16        15        90       3       1     #pragma omp parallel num_threads(numt)
            .    .    .             .           .         .         .       .       .     {
           12    2    2             0           0         0        12       9       9        int tid = omp_get_thread_num();
        9,093    0    0            24           0         0         0       0       0        for(int r=tid; r<R.num(); r+=numt) { // Thread together share-loop through the intervals 
        3,003    0    0             0           0         0         0       0       0           int rcount = 0;
9,090,738,657    0    0         3,003       2,991        46         0       0       0           for(int d=0; d<D.ndata; d++) // For each interval, thread loops through all of data and  
6,060,486,432    3    3 3,030,243,216 378,783,407 2,802,992         0       0       0               if(D.data[d].value == r) // If the data item is in this interval 
3,051,445,740    0    0    12,108,864       5,991     1,569 3,027,216 381,042 380,604                   D2.data[rangecount[r-1]+rcount++] = D.data[d]; // Copy it to the appropriate place in D2.
            .    .    .             .           .         .         .       .       .        }
            .    .    .             .           .         .         .       .       .     }
            .    .    .             .           .         .         .       .       .  
            6    0    0             6           0         0         0       0       0     return D2;
           36    0    0            27           6         6         0       0       0  }

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr        DLmr      Dw         D1mw    DLmw    
--------------------------------------------------------------------------------
33,390,008,777   49   48 6,087,246,962 380,337,806 2,982,089 14,337,310 452,813 452,348  events annotated

