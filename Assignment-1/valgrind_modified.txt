==4265== Cachegrind, a cache and branch-prediction profiler
==4265== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==4265== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==4265== Command: ./classify rfile dfile 1009072 4 3
==4265== 
--4265-- warning: L3 cache found, using its data for the LL simulation.
11712.8 ms
11654.3 ms
11915.8 ms
3 iterations of 1009072 items in 1001 ranges with 4 threads: Fastest took 11654.3 ms, Average was 11761 ms
==4265== 
==4265== I   refs:      16,168,243,596
==4265== I1  misses:             3,730
==4265== LLi misses:             3,570
==4265== I1  miss rate:           0.00%
==4265== LLi miss rate:           0.00%
==4265== 
==4265== D   refs:       3,456,299,301  (3,349,586,943 rd   + 106,712,358 wr)
==4265== D1  misses:         3,625,881  (    2,168,338 rd   +   1,457,543 wr)
==4265== LLd misses:         2,639,044  (    1,469,949 rd   +   1,169,095 wr)
==4265== D1  miss rate:            0.1% (          0.1%     +         1.4%  )
==4265== LLd miss rate:            0.1% (          0.0%     +         1.1%  )
==4265== 
==4265== LL refs:            3,629,611  (    2,172,068 rd   +   1,457,543 wr)
==4265== LL misses:          2,642,614  (    1,473,519 rd   +   1,169,095 wr)
==4265== LL miss rate:             0.0% (          0.0%     +         1.1%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./classify rfile dfile 1009072 4 3
Data file:        cachegrind.out.4265
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr            D1mr      DLmr      Dw          D1mw      DLmw      
--------------------------------------------------------------------------------
16,168,243,596 3,730 3,570 3,349,586,943 2,168,338 1,469,949 106,712,358 1,457,543 1,169,095  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr      DLmr      Dw         D1mw    DLmw     file:function
--------------------------------------------------------------------------------
15,116,191,724    7    7 3,028,689,333     1,497       378          0       0       0  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:Ranges::range(int, bool) const
   519,253,851   36   36   172,281,847       339       210 53,900,944       0       0  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   148,888,285  705  688    40,343,310       837       449  9,102,271     232     175  ???:???
   142,279,452    8    8    39,353,940 1,515,925 1,447,016  6,054,492 381,042 354,842  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
    62,687,028    9    9    25,276,949        45        41  7,077,639       0       0  ???:std::istream::sentry::sentry(std::istream&, bool)
    55,609,012    5    5    17,188,240         2         1 10,110,730 126,135   1,759  ???:std::istream::operator>>(int&)
    54,238,056    8    8    15,640,776   631,449    11,658  6,054,540       9       8  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr      DLmr      Dw        D1mw    DLmw    

            .    .    .             .         .         .         .       .       .  #include "classify.h"
            .    .    .             .         .         .         .       .       .  #include <omp.h>
            .    .    .             .         .         .         .       .       .  #include <vector>
            .    .    .             .         .         .         .       .       .  #include <utility>
            .    .    .             .         .         .         .       .       .  #include <chrono>
            .    .    .             .         .         .         .       .       .  
        1,000    1    1             0         0         0         0       0       0  Range::Range(int a=1, int b=0) {
      502,501    0    0             0         0         0   502,501  61,877  61,877     lo = a;
    1,004,000    0    0             0         0         0   502,500       0       0     hi = b;
        1,000    0    0         1,000         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  bool Range::within(int val) const {
6,035,199,372    0    0 3,017,599,686     1,497       378         0       0       0        return(lo <= val && val <= hi);
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  bool Range::strictlyin(int val) const {
    5,002,998    0    0     2,001,999         0         0         0       0       0        return(lo < val && val < hi);
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  void Ranges::set(int i, int lo, int hi) {
            .    .    .             .         .         .         .       .       .     if(i < _num) {
      501,500    0    0             0         0         0   501,500       0       0        _ranges[i].lo = lo;
    1,001,000    0    0             0         0         0   500,500       0       0        _ranges[i].hi = hi;
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
            3    1    1             0         0         0         1       0       0  Ranges::Ranges() {
            1    0    0             0         0         0         1       0       0     _num = 1;
            3    0    0             0         0         0         2       0       0     _ranges = new Range(1, 0);
            2    0    0             2         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
        8,000    2    2             0         0         0     5,000       0       0  Ranges& Ranges::operator+=(const Range range){
        3,000    0    0             0         0         0     1,000       0       0     if(newrange(range)) {
        1,000    0    0         1,000         0         0         0       0       0        Range *oranges = _ranges;
    1,018,000    1    1         1,000         0         0     2,000       0       0        _ranges = new Range[_num+1];
            .    .    .             .         .         .         .       .       .        assert(NULL != _ranges);
    1,507,500    0    0         1,000         0         0         0       0       0        for(int r=0; r<_num; r++) { 
    1,001,000    1    1     1,001,000         0         0         0       0       0           set(r, oranges[r].lo, oranges[r].hi);
            .    .    .             .         .         .         .       .       .        }
        2,000    0    0             0         0         0     1,000       0       0        set(_num++, range.lo, range.hi);
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .     return *this;
        7,000    0    0         6,000         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  int Ranges::range_binary(int val, bool strict = false) const {
            .    .    .             .         .         .         .       .       .     int low = 0, high = _num - 1, mid = 0;
            .    .    .             .         .         .         .       .       .     if(strict) {
            .    .    .             .         .         .         .       .       .        while(low <= high) {
            .    .    .             .         .         .         .       .       .           mid = (low + high) / 2;
            .    .    .             .         .         .         .       .       .           if(_ranges[mid].strictlyin(val))
            .    .    .             .         .         .         .       .       .              return mid;
-- line 51 ----------------------------------------
-- line 67 ----------------------------------------
            .    .    .             .         .         .         .       .       .           else {
            .    .    .             .         .         .         .       .       .              high = mid - 1;
            .    .    .             .         .         .         .       .       .           }
            .    .    .             .         .         .         .       .       .        }
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .     return BADRANGE;
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
    3,029,216    4    4             0         0         0         0       0       0  int Ranges::range(int val, bool strict = false) const {
    9,087,648    0    0     3,029,216         0         0         0       0       0     if(strict) {
    5,005,000    1    1             0         0         0         0       0       0        for(int r=0; r<_num; r++)
        8,000    0    0         2,000         0         0         0       0       0           if(_ranges[r].strictlyin(val))
            .    .    .             .         .         .         .       .       .              return r;
            .    .    .             .         .         .         .       .       .     } else {
7,534,917,567    1    1             0         0         0         0       0       0        for(int r=0; r<_num; r++)
1,517,881,491    0    0     3,027,216         0         0         0       0       0           if(_ranges[r].within(val))
            .    .    .             .         .         .         .       .       .              return r;
            .    .    .             .         .         .         .       .       .     }
        2,000    1    1             0         0         0         0       0       0     return BADRANGE;
    6,058,432    0    0     3,029,216         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  void Ranges::inspect() {
            .    .    .             .         .         .         .       .       .     for(int r=0; r<_num; r++) { 
            .    .    .             .         .         .         .       .       .        std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
       15,003    1    1             2         0         0         0       0       0  int Ranges::num() const { return _num; }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  
        2,000    1    1             0         0         0         0       0       0  bool Ranges::newrange(const Range r) {
       12,000    0    0             0         0         0     2,000       0       0     return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE);
        1,000    0    0         1,000         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
    4,036,288    1    1             0         0         0 3,027,216 378,402 378,402  Item::Item() {
    7,063,504    3    3             0         0         0 4,036,288 126,134 126,134     key = value = -1;
    1,009,072    0    0     1,009,072         0         0         0       0       0  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  Item::Item(int a, int b) {
            .    .    .             .         .         .         .       .       .     key = a;
            .    .    .             .         .         .         .       .       .     value = b;
            .    .    .             .         .         .         .       .       .  }
            .    .    .             .         .         .         .       .       .  
            .    .    .             .         .         .         .       .       .  Data classify(Data &D, const Ranges &R, unsigned int numt)
           42    5    5             3         0         0        30       2       1  {  
            6    0    0             0         0         0         0       0       0     assert(numt < MAXTHREADS);
            .    .    .             .         .         .         .       .       .     
            9    0    0             9         2         2         0       0       0     std::vector<std::vector<unsigned int>> counts(numt, std::vector<unsigned int>(R.num(), 0));
            .    .    .             .         .         .         .       .       .     int k = 12;
          282    5    5           117        22         0       102       9       8     #pragma omp parallel num_threads(numt)
            .    .    .             .         .         .         .       .       .     {
           12    0    0             0         0         0        12       0       0        int tid = omp_get_thread_num(); // I am thread number tid
           24    2    2             0         0         0         0       0       0        int index = k * tid;
      504,600    0    0            24         0         0         0       0       0        while(index < D.ndata) {
   19,929,192    4    4     3,279,486         0         0         0       0       0           for(int j = index; j < (index + k) && j < D.ndata; j ++) {
   24,217,740    0    0     6,054,444   630,672    11,517 6,054,432       0       0              int v = D.data[j].value = R.range(D.data[j].key);
    9,081,672    0    0     6,054,444       755       141         0       0       0              counts[tid][v] ++;
            .    .    .             .         .         .         .       .       .           }
      504,576    0    0       252,270         0         0        12       0       0           index += k * numt;
            .    .    .             .         .         .         .       .       .        }
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .  
       12,048    1    1             3         0         0     3,006     185     185     unsigned int *rangecount = new unsigned int[R.num()]();
            .    .    .             .         .         .         .       .       .     int p = -1;
           93    3    3            15         0         0         0       0       0     for(int t = 0; t < numt; t ++) {
       24,024    0    0             0         0         0         0       0       0        for(int r = 1; r < R.num(); r ++) {
       24,036    0    0        24,012       753       203         0       0       0           rangecount[r] += counts[t][r];   
            .    .    .             .         .         .         .       .       .        }
            .    .    .             .         .         .         .       .       .     }
        6,018    3    3             0         0         0         0       0       0     for(int r = 1; r < R.num(); r ++) {
        6,000    0    0         6,000         0         0         0       0       0        rangecount[r] += rangecount[r - 1];
            .    .    .             .         .         .         .       .       .     }
            .    .    .             .         .         .         .       .       .     
            6    0    0             6         0         0         0       0       0     Data D2 = Data(D.ndata);
       12,051    3    3             6         3         3     3,006     188     186     unsigned int *rangeIndex = new unsigned int[R.num()]();
          228    3    3           102        12        12        66       3       3     #pragma omp parallel num_threads(numt)
            .    .    .             .         .         .         .       .       .     {
           12    0    0             0         0         0        12       0       0        int tid = omp_get_thread_num();
   36,326,688    6    6    12,108,900         0         0         0       0       0        for(int d = 0; d < D.ndata; d ++) {
   12,108,864    0    0    12,108,864 1,513,620 1,445,649         0       0       0            int r = D.data[d].value;
   60,544,320    0    0             0         0         0         0       0       0            if(tid == r % numt) {
   33,299,376    0    0    15,136,080     2,293     1,355 6,054,432 381,042 354,842                D2.data[rangecount[r - 1] + rangeIndex[r] ++] = D.data[d];
            .    .    .             .         .         .         .       .       .            }
            .    .    .             .         .         .         .       .       .        }
            .    .    .             .         .         .         .       .       .     }
           12    0    0             6         0         0         0       0       0     return D2;
           36    1    1            27         4         3         0       0       0  }

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr      DLmr      Dw         D1mw    DLmw    
--------------------------------------------------------------------------------
15,331,491,068   55   55 3,085,735,227 2,149,633 1,459,263 21,196,619 947,842 921,638  events annotated

