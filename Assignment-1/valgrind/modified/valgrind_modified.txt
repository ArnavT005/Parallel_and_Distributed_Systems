==5124== Cachegrind, a cache and branch-prediction profiler
==5124== Copyright (C) 2002-2017, and GNU GPL'd, by Nicholas Nethercote et al.
==5124== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==5124== Command: ./classify rfile dfile 1009072 4 3
==5124== 
--5124-- warning: L3 cache found, using its data for the LL simulation.
14629 ms
==5124== brk segment overflow in thread #1: can't grow to 0x4a0e000
==5124== (see section Limitations in user manual)
==5124== NOTE: further instances of this message will not be shown
15788.9 ms
15571.5 ms
3 iterations of 1009072 items in 1001 ranges with 4 threads: Fastest took 14629 ms, Average was 15329.8 ms
==5124== 
==5124== I   refs:      16,247,971,142
==5124== I1  misses:             3,902
==5124== LLi misses:             3,737
==5124== I1  miss rate:           0.00%
==5124== LLi miss rate:           0.00%
==5124== 
==5124== D   refs:       3,491,796,095  (3,354,806,963 rd   + 136,989,132 wr)
==5124== D1  misses:         4,758,368  (    1,789,323 rd   +   2,969,045 wr)
==5124== LLd misses:         3,785,572  (    1,093,540 rd   +   2,692,032 wr)
==5124== D1  miss rate:            0.1% (          0.1%     +         2.2%  )
==5124== LLd miss rate:            0.1% (          0.0%     +         2.0%  )
==5124== 
==5124== LL refs:            4,762,270  (    1,793,225 rd   +   2,969,045 wr)
==5124== LL misses:          3,789,309  (    1,097,277 rd   +   2,692,032 wr)
==5124== LL miss rate:             0.0% (          0.0%     +         2.0%  )

--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./classify rfile dfile 1009072 4 3
Data file:        cachegrind.out.5124
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr  ILmr  Dr            D1mr      DLmr      Dw          D1mw      DLmw      
--------------------------------------------------------------------------------
16,247,971,142 3,902 3,737 3,354,806,963 1,789,323 1,093,540 136,989,132 2,969,045 2,692,032  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr    DLmr    Dw         D1mw    DLmw     file:function
--------------------------------------------------------------------------------
15,116,191,724    8    8 3,028,689,333   1,498     376          0       0       0  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:Ranges::range(int, bool) const
   519,253,851   36   36   172,281,847     339     210 53,900,944       0       0  ???:std::istreambuf_iterator<char, std::char_traits<char> > std::num_get<char, std::istreambuf_iterator<char, std::char_traits<char> > >::_M_extract_int<long>(std::istreambuf_iterator<char, std::char_traits<char> >, std::istreambuf_iterator<char, std::char_traits<char> >, std::ios_base&, std::_Ios_Iostate&, long&) const
   158,951,098  708  690    41,781,456   1,094     448  9,103,038     324     254  ???:???
    62,687,028   10   10    25,276,949      45      41  7,077,639       0       0  ???:std::istream::sentry::sentry(std::istream&, bool)
    55,609,012    5    5    17,188,240       2       1 10,110,730 126,135   1,807  ???:std::istream::operator>>(int&)
    54,661,632   26   26     6,108,627 379,243 378,615  9,084,735 378,595 378,588  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int)
    54,238,056    9    9    15,640,776 631,454   9,584  6,054,540      13       9  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.0]
    48,435,990    9    9    12,109,029 378,851 378,616  3,027,300       9       9  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.1]
    40,037,310    6    6    10,574,340 378,455 315,431  6,054,468 378,410 378,408  /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp:classify(Data&, Ranges const&, unsigned int) [clone ._omp_fn.2]
    18,163,416    0    0             0       0       0          0       0       0  /usr/include/c++/9/bits/stl_uninitialized.h:std::vector<std::pair<int, int>, std::allocator<std::pair<int, int> > >::_M_default_append(unsigned long)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/snake/Desktop/Parallel_and_Distributed_Systems/Assignment-1/classify.cpp
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr    DLmr    Dw        D1mw    DLmw    

            .    .    .             .       .       .         .       .       .  #include "classify.h"
            .    .    .             .       .       .         .       .       .  #include <omp.h>
            .    .    .             .       .       .         .       .       .  #include <vector>
            .    .    .             .       .       .         .       .       .  #include <utility>
            .    .    .             .       .       .         .       .       .  #include <chrono>
            .    .    .             .       .       .         .       .       .  
        1,000    1    1             0       0       0         0       0       0  Range::Range(int a=1, int b=0) {
      502,501    0    0             0       0       0   502,501  61,877  61,877     lo = a;
    1,004,000    1    1             0       0       0   502,500       0       0     hi = b;
        1,000    0    0         1,000       0       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  bool Range::within(int val) const {
6,035,199,372    0    0 3,017,599,686   1,495     376         0       0       0        return(lo <= val && val <= hi);
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  bool Range::strictlyin(int val) const {
    5,002,998    0    0     2,001,999       0       0         0       0       0        return(lo < val && val < hi);
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  void Ranges::set(int i, int lo, int hi) {
            .    .    .             .       .       .         .       .       .     if(i < _num) {
      501,500    1    1             0       0       0   501,500       0       0        _ranges[i].lo = lo;
    1,001,000    0    0             0       0       0   500,500       0       0        _ranges[i].hi = hi;
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
            3    1    1             0       0       0         1       0       0  Ranges::Ranges() {
            1    0    0             0       0       0         1       0       0     _num = 1;
            3    1    1             0       0       0         2       0       0     _ranges = new Range(1, 0);
            2    0    0             2       0       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
        8,000    1    1             0       0       0     5,000       0       0  Ranges& Ranges::operator+=(const Range range){
        3,000    0    0             0       0       0     1,000       0       0     if(newrange(range)) {
        1,000    0    0         1,000       0       0         0       0       0        Range *oranges = _ranges;
    1,018,000    1    1         1,000       0       0     2,000       0       0        _ranges = new Range[_num+1];
            .    .    .             .       .       .         .       .       .        assert(NULL != _ranges);
    1,507,500    0    0         1,000       0       0         0       0       0        for(int r=0; r<_num; r++) { 
    1,001,000    0    0     1,001,000       0       0         0       0       0           set(r, oranges[r].lo, oranges[r].hi);
            .    .    .             .       .       .         .       .       .        }
        2,000    0    0             0       0       0     1,000       0       0        set(_num++, range.lo, range.hi);
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     return *this;
        7,000    0    0         6,000       0       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  int Ranges::range_binary(int val, bool strict = false) const {
            .    .    .             .       .       .         .       .       .     int low = 0, high = _num - 1, mid = 0;
            .    .    .             .       .       .         .       .       .     if(strict) {
            .    .    .             .       .       .         .       .       .        while(low <= high) {
            .    .    .             .       .       .         .       .       .           mid = (low + high) / 2;
            .    .    .             .       .       .         .       .       .           if(_ranges[mid].strictlyin(val))
            .    .    .             .       .       .         .       .       .              return mid;
-- line 51 ----------------------------------------
-- line 67 ----------------------------------------
            .    .    .             .       .       .         .       .       .           else {
            .    .    .             .       .       .         .       .       .              high = mid - 1;
            .    .    .             .       .       .         .       .       .           }
            .    .    .             .       .       .         .       .       .        }
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     return BADRANGE;
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
    3,029,216    3    3             0       0       0         0       0       0  int Ranges::range(int val, bool strict = false) const {
    9,087,648    0    0     3,029,216       0       0         0       0       0     if(strict) {
    5,005,000    0    0             0       0       0         0       0       0        for(int r=0; r<_num; r++)
        8,000    1    1         2,000       0       0         0       0       0           if(_ranges[r].strictlyin(val))
            .    .    .             .       .       .         .       .       .              return r;
            .    .    .             .       .       .         .       .       .     } else {
7,534,917,567    3    3             0       0       0         0       0       0        for(int r=0; r<_num; r++)
1,517,881,491    0    0     3,027,216       0       0         0       0       0           if(_ranges[r].within(val))
            .    .    .             .       .       .         .       .       .              return r;
            .    .    .             .       .       .         .       .       .     }
        2,000    1    1             0       0       0         0       0       0     return BADRANGE;
    6,058,432    0    0     3,029,216       3       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  void Ranges::inspect() {
            .    .    .             .       .       .         .       .       .     for(int r=0; r<_num; r++) { 
            .    .    .             .       .       .         .       .       .        std::cout << r << "," << &_ranges[r] << ": " << _ranges[r].lo << ", " << _ranges[r].hi << "\n"; 
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
        3,027    1    1            26      12       3         0       0       0  int Ranges::num() const { return _num; }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  
        2,000    1    1             0       0       0         0       0       0  bool Ranges::newrange(const Range r) {
       12,000    0    0             0       0       0     2,000       0       0     return (range(r.lo, true) == BADRANGE && range(r.hi, true) == BADRANGE);
        1,000    0    0         1,000       0       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
    7,063,504    0    0             0       0       0 3,027,216 378,402 378,402  Item::Item() {
    7,063,504    0    0             0       0       0 4,036,288 126,134 126,134     key = value = -1;
    1,009,072    0    0     1,009,072       0       0         0       0       0  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  Item::Item(int a, int b) {
            .    .    .             .       .       .         .       .       .     key = a;
            .    .    .             .       .       .         .       .       .     value = b;
            .    .    .             .       .       .         .       .       .  }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .  Data classify(Data &D, const Ranges &R, unsigned int numt)
           39    3    3             3       0       0        27       2       0  {  
            6    0    0             0       0       0         0       0       0     assert(numt < MAXTHREADS);
            .    .    .             .       .       .         .       .       .     
           12    2    2             6       2       0         0       0       0     std::vector<std::vector<unsigned int>> counts(numt, std::vector<unsigned int>(R.num(), 0));
            .    .    .             .       .       .         .       .       .     // std::vector<std::vector<int>> range(numt, std::vector<int>((int)(D.ndata / numt) + 1, 0));
            .    .    .             .       .       .         .       .       .     // #pragma omp parallel num_threads(numt)
            .    .    .             .       .       .         .       .       .     // {
            .    .    .             .       .       .         .       .       .     //    int tid = omp_get_thread_num();
            .    .    .             .       .       .         .       .       .     //    for(int i=tid; i<D.ndata; i+=numt) { 
            .    .    .             .       .       .         .       .       .     //       // int v = range[tid][i / numt] = R.range(D.data[i].key);
            .    .    .             .       .       .         .       .       .     //       int v = D.data[i].value = R.range(D.data[i].key);
            .    .    .             .       .       .         .       .       .     //       counts[tid][v] ++;
            .    .    .             .       .       .         .       .       .     //    }
            .    .    .             .       .       .         .       .       .     // }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .     int k = 12;
          285    7    7           114      21       0       105       8       8     #pragma omp parallel num_threads(numt)
            .    .    .             .       .       .         .       .       .     {
           12    0    0             0       0       0        12       1       1        int tid = omp_get_thread_num(); // I am thread number tid
           24    0    0             0       0       0         0       0       0        int index = k * tid;
      504,600    0    0            24       0       0         0       0       0        while(index < D.ndata) {
   19,929,192    3    3     3,279,486       0       0         0       0       0           for(int j = index; j < (index + k) && j < D.ndata; j ++) {
            .    .    .             .       .       .         .       .       .              // int v = range[tid][(j / (k * numt)) * k + j % k] = R.range(D.data[j].key);
   24,217,740    0    0     6,054,444 630,673   9,484 6,054,432       4       0              int v = D.data[j].value = R.range(D.data[j].key);
    9,081,672    0    0     6,054,444     760     100         0       0       0              counts[tid][v] ++;
            .    .    .             .       .       .         .       .       .           }
      504,576    0    0       252,270       0       0        12       0       0           index += k * numt;
            .    .    .             .       .       .         .       .       .        }
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .  
       12,048    2    2             3       0       0     3,006     185     185     unsigned int *rangecount = new unsigned int[R.num()]();
            .    .    .             .       .       .         .       .       .     std::vector<int> partition_size(numt, 0);
            .    .    .             .       .       .         .       .       .     int p = -1;
           84    0    0             6       0       0         0       0       0     for(int t = 0; t < numt; t ++) {
       24,024    3    3             0       0       0         0       0       0        for(int r = 1; r < R.num(); r ++) {
       24,084    0    0        24,012     754     192         0       0       0           rangecount[r] += counts[t][r];   
       36,000    0    0             0       0       0         0       0       0           if(r / (R.num() / numt) >= numt)
       24,000    0    0             0       0       0         0       0       0              p = numt - 1;
            .    .    .             .       .       .         .       .       .           else
            .    .    .             .       .       .         .       .       .              p = r / (R.num() / numt);
       36,000    0    0        24,000       0       0         0       0       0           partition_size[p] += counts[t][r];
            .    .    .             .       .       .         .       .       .        }
            .    .    .             .       .       .         .       .       .     }
        6,018    0    0             0       0       0         0       0       0     for(int r = 1; r < R.num(); r ++) {
        6,000    1    1         6,000       0       0         0       0       0        rangecount[r] += rangecount[r - 1];
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     
            .    .    .             .       .       .         .       .       .     std::vector<std::vector<std::pair<int, int>>> partitions(numt, std::vector<std::pair<int, int>>(0));
           48    0    0             9       9       0         0       0       0     for(int i = 0; i < numt; i ++) {
           24    0    0            24      15       3         0       0       0        partitions[i].resize(partition_size[i]);
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     std::vector<int> threadIndex(numt, 0);
    6,054,453    0    0             9       9       7         3       0       0     for(int i = 0; i < D.ndata; i ++) {
            .    .    .             .       .       .         .       .       .        // int r = range[i % numt][i / numt], p = -1;
    3,027,216    0    0     3,027,216 378,405 378,405         0       0       0        int r = D.data[i].value, p = -1;
            .    .    .             .       .       .         .       .       .        // int r = range[(i / k) % numt][(i / (k * numt)) * k + i % k], p = -1;
   12,108,897    2    2            15       0       0         0       0       0        if(r / (R.num() / numt) >= numt)
    6,054,435    0    0             0       0       0         0       0       0           p = numt - 1;
            .    .    .             .       .       .         .       .       .        else
            .    .    .             .       .       .         .       .       .           p = r / (R.num() / numt);
   15,136,083    3    3     3,027,219       3       0 3,027,216       0       0        partitions[p][threadIndex[p] ++] = {D.data[i].key, r};
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .  
            .    .    .             .       .       .         .       .       .     Data D2 = Data(D.ndata); // Make a copy
            .    .    .             .       .       .         .       .       .     
            .    .    .             .       .       .         .       .       .     std::vector<std::vector<std::pair<int, int>>> items(numt, std::vector<std::pair<int, int>>(0));
           60    0    0             9       9       0         0       0       0     for(int i = 0; i < numt; i ++) {
           24    0    0            24       9       3         0       0       0        items[i].resize(partition_size[i]);
           24    0    0             0       0       0         0       0       0        if(i != 0) 
           27    0    0            27      18       0         0       0       0           partition_size[i] += partition_size[i - 1];
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     
          258    7    7           102      27       1        90       3       1     #pragma omp parallel num_threads(numt)
            .    .    .             .       .       .         .       .       .     {
           24    3    3             0       0       0        12       9       9        int tid = omp_get_thread_num();
          108    0    0             0       0       0         0       0       0        int lower = tid * (R.num() / numt), upper = (tid + 1 == numt) ? R.num() : (tid + 1) * (R.num() / numt);
           24    0    0             0       0       0         0       0       0        std::vector<int> rangeIndex(upper - lower, 0);
           54    1    1             9       8       6         0       0       0        int temp = (lower == 0) ? 0 : rangecount[lower - 1];
    6,054,480    0    0            24      11       6         0       0       0        for(int i = 0; i < partitions[tid].size(); i ++) {
    3,027,216    3    3     3,027,216 378,414 378,413         0       0       0           int r = partitions[tid][i].second;
    6,054,432    0    0             0       0       0         0       0       0           if(r == -1) 
            .    .    .             .       .       .         .       .       .              break;
   33,299,412    0    0     9,081,660     382     188 3,027,216       0       0           items[tid][rangecount[r - 1] - temp + rangeIndex[r - lower] ++] = {partitions[tid][i].first, r};
            .    .    .             .       .       .         .       .       .        } 
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .  
          138    5    5            36      15       0        36       3       0     #pragma omp parallel num_threads(numt)
            .    .    .             .       .       .         .       .       .     {
           12    0    0             0       0       0        12       0       0        int tid = omp_get_thread_num();
    6,054,492    0    0            24      18       5         0       0       0        for(int i = 0; i < items[tid].size(); i ++) {
   12,108,864    0    0     6,054,432 378,412 315,417         0       0       0           if(tid == 0) {
      767,310    0    0             0       0       0   767,310  95,916  95,915              D2.data[i].key = items[tid][i].first;
      767,310    0    0             0       0       0   767,310       0       0              D2.data[i].value = items[tid][i].second;
            .    .    .             .       .       .         .       .       .           }
            .    .    .             .       .       .         .       .       .           else {
    9,039,684    3    3     2,259,942      10       9 2,259,906 282,494 282,493              D2.data[partition_size[tid - 1] + i].key = items[tid][i].first;
   11,299,530    0    0     2,259,906       0       0 2,259,906       0       0              D2.data[partition_size[tid - 1] + i].value = items[tid][i].second;
            .    .    .             .       .       .         .       .       .           }
            .    .    .             .       .       .         .       .       .        }
            .    .    .             .       .       .         .       .       .     }
            .    .    .             .       .       .         .       .       .     // int globalIndex = 0, tid = 0, tIndex = 0;
            .    .    .             .       .       .         .       .       .     // while(globalIndex < D2.ndata) {
            .    .    .             .       .       .         .       .       .     //    if(tIndex < partitions[tid].size()) {
            .    .    .             .       .       .         .       .       .     //       D2.data[globalIndex].key = items[tid][tIndex].first;
            .    .    .             .       .       .         .       .       .     //       D2.data[globalIndex].value = items[tid][tIndex].second;
-- line 215 ----------------------------------------
-- line 216 ----------------------------------------
            .    .    .             .       .       .         .       .       .     //       tIndex ++;
            .    .    .             .       .       .         .       .       .     //       globalIndex ++;
            .    .    .             .       .       .         .       .       .     //    }
            .    .    .             .       .       .         .       .       .     //    else {
            .    .    .             .       .       .         .       .       .     //       tid ++;
            .    .    .             .       .       .         .       .       .     //       tIndex = 0;
            .    .    .             .       .       .         .       .       .     //    }
            .    .    .             .       .       .         .       .       .     // }
           12    0    0             6       1       1         0       0       0     return D2;
           36    3    3            27       6       3         0       0       0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/9/bits/stl_uninitialized.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 213 ----------------------------------------
         .    .    .  .    .    .  .    .    .        template<typename _ForwardIterator, typename _Size, typename _Tp>
         .    .    .  .    .    .  .    .    .          static _ForwardIterator
         .    .    .  .    .    .  .    .    .          __uninit_fill_n(_ForwardIterator __first, _Size __n,
         .    .    .  .    .    .  .    .    .  			const _Tp& __x)
         .    .    .  .    .    .  .    .    .          {
         .    .    .  .    .    .  .    .    .  	  _ForwardIterator __cur = __first;
         .    .    .  .    .    .  .    .    .  	  __try
         .    .    .  .    .    .  .    .    .  	    {
       117    0    0  0    0    0  0    0    0  	      for (; __n > 0; --__n, (void) ++__cur)
         .    .    .  .    .    .  .    .    .  		std::_Construct(std::__addressof(*__cur), __x);
         .    .    .  .    .    .  .    .    .  	      return __cur;
         .    .    .  .    .    .  .    .    .  	    }
         .    .    .  .    .    .  .    .    .  	  __catch(...)
         .    .    .  .    .    .  .    .    .  	    {
         .    .    .  .    .    .  .    .    .  	      std::_Destroy(__first, __cur);
         .    .    .  .    .    .  .    .    .  	      __throw_exception_again;
         .    .    .  .    .    .  .    .    .  	    }
-- line 229 ----------------------------------------
-- line 536 ----------------------------------------
         .    .    .  .    .    .  .    .    .      {
         .    .    .  .    .    .  .    .    .        template<typename _ForwardIterator, typename _Size>
         .    .    .  .    .    .  .    .    .          static _ForwardIterator
         .    .    .  .    .    .  .    .    .          __uninit_default_n(_ForwardIterator __first, _Size __n)
         .    .    .  .    .    .  .    .    .          {
         .    .    .  .    .    .  .    .    .  	  _ForwardIterator __cur = __first;
         .    .    .  .    .    .  .    .    .  	  __try
         .    .    .  .    .    .  .    .    .  	    {
18,163,320    0    0  0    0    0  0    0    0  	      for (; __n > 0; --__n, (void) ++__cur)
         .    .    .  .    .    .  .    .    .  		std::_Construct(std::__addressof(*__cur));
         .    .    .  .    .    .  .    .    .  	      return __cur;
         .    .    .  .    .    .  .    .    .  	    }
         .    .    .  .    .    .  .    .    .  	  __catch(...)
         .    .    .  .    .    .  .    .    .  	    {
         .    .    .  .    .    .  .    .    .  	      std::_Destroy(__first, __cur);
         .    .    .  .    .    .  .    .    .  	      __throw_exception_again;
         .    .    .  .    .    .  .    .    .  	    }
-- line 552 ----------------------------------------
-- line 940 ----------------------------------------
         .    .    .  .    .    .  .    .    .  					       __alloc)))
         .    .    .  .    .    .  .    .    .      {
         .    .    .  .    .    .  .    .    .        typedef typename iterator_traits<_InputIterator>::value_type
         .    .    .  .    .    .  .    .    .  	_ValueType;
         .    .    .  .    .    .  .    .    .        typedef typename iterator_traits<_ForwardIterator>::value_type
         .    .    .  .    .    .  .    .    .  	_ValueType2;
         .    .    .  .    .    .  .    .    .        static_assert(std::is_same<_ValueType, _ValueType2>::value,
         .    .    .  .    .    .  .    .    .  	  "relocation is only possible for values of the same type");
        24    0    0  0    0    0  0    0    0        _ForwardIterator __cur = __result;
        72    0    0  0    0    0  0    0    0        for (; __first != __last; ++__first, (void)++__cur)
         .    .    .  .    .    .  .    .    .  	std::__relocate_object_a(std::__addressof(*__cur),
         .    .    .  .    .    .  .    .    .  				 std::__addressof(*__first), __alloc);
         .    .    .  .    .    .  .    .    .        return __cur;
         .    .    .  .    .    .  .    .    .      }
         .    .    .  .    .    .  .    .    .  
         .    .    .  .    .    .  .    .    .    template <typename _InputIterator, typename _ForwardIterator,
         .    .    .  .    .    .  .    .    .  	    typename _Allocator>
         .    .    .  .    .    .  .    .    .      inline _ForwardIterator
-- line 957 ----------------------------------------

--------------------------------------------------------------------------------
Ir             I1mr ILmr Dr            D1mr      DLmr      Dw         D1mw    DLmw    
--------------------------------------------------------------------------------
15,341,328,977   68   68 3,075,143,181 1,769,501 1,082,622 27,248,120 945,038 945,025  events annotated

